module FJ.Syntax.Skelfj_syntax where

-- Haskell module generated by the BNF converter

import FJ.Syntax.Absfj_syntax
import FJ.Syntax.ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transId :: Id -> Result
transId x = case x of
  Id str  -> failure x


transProgram :: Program -> Result
transProgram x = case x of
  CProgram classdecls exp  -> failure x


transClassDecl :: ClassDecl -> Result
transClassDecl x = case x of
  CDecl id type' fielddecls constructor methoddecls  -> failure x


transFieldDecl :: FieldDecl -> Result
transFieldDecl x = case x of
  FDecl type' id  -> failure x


transConstructor :: Constructor -> Result
transConstructor x = case x of
  KDecl id fields args assignments  -> failure x


transField :: Field -> Result
transField x = case x of
  Field type' id  -> failure x


transFormalArg :: FormalArg -> Result
transFormalArg x = case x of
  FormalArg type' id  -> failure x


transArg :: Arg -> Result
transArg x = case x of
  Arg id  -> failure x


transAssignment :: Assignment -> Result
transAssignment x = case x of
  Assignment id1 id2  -> failure x


transMethodDecl :: MethodDecl -> Result
transMethodDecl x = case x of
  MethodDecl type' id formalargs term  -> failure x


transTerm :: Term -> Result
transTerm x = case x of
  TermVar id  -> failure x
  TermFieldAccess term id  -> failure x
  TermMethodInvoc term id terms  -> failure x
  TermExp exp  -> failure x


transExp :: Exp -> Result
transExp x = case x of
  CastExp type' term  -> failure x
  NewExp id terms  -> failure x


transType :: Type -> Result
transType x = case x of
  TypeObject  -> failure x
  TypeId id  -> failure x



