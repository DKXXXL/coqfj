Require Import String.
Require Import FJ.Lists.
Require Import FJ.Base.

Notation "'[' X ']'" := (list X) (at level 40).

(* We could use Inductive for ClassNames and Vars, 
 * but would make the other definitions cumbersome to deal with 
 * the special names Object and this.
 * ClassNames are our types.
 *)
Definition ClassName := id.
(* Given a ClassTable, 
    the programmer needs to specify which ID is the Object *)
Parameter Object: ClassName.

(* Vars must appear only inside methods body *)
Definition Var := id.
(* Similar for this variable *)
Parameter this: Var.

Inductive Argument :=
  | Arg : id -> Argument.

(* FormalArg and FieldDecl is a ClassName (i.e. a type) and an id *)
Inductive FormalArg :=
  | FArg : ClassName -> id -> FormalArg.
Inductive FieldDecl :=
  | FDecl : ClassName -> id -> FieldDecl.

(* The class Referable essentialy means I can use the ref function
 * to retrieve the id of a value.
 * And it also gives me a nice function ´find´ for free.
 * See Util.Referable
*)
Instance FargRef : Referable FormalArg :={
  ref farg := 
    match farg with 
   | FArg _ id => id end
}.
Instance FieldRef : Referable FieldDecl :={
  ref fdecl := 
    match fdecl with 
   | FDecl _ id => id end
}.

(* fargType and fieldType are a means to retrieve the Type of the declarations *)
Definition fargType (f: FormalArg):ClassName := 
  match f with FArg t _ => t end.
Definition fieldType (f: FieldDecl): ClassName := 
  match f with FDecl t _ => t end.

(* Our expressions are Variables,
 * field acesses,
 * method invocations,
 * cast
 * and new
*)
Inductive Exp : Type :=
  | ExpVar : Var -> Exp
  | ExpFieldAccess : Exp -> id -> Exp
  | ExpMethodInvoc : Exp -> id -> [Exp] -> Exp
  | ExpCast : ClassName -> Exp -> Exp
  | ExpNew : id -> [Exp] -> Exp.

Inductive Assignment :=
  | Assgnmt : Exp -> Exp -> Assignment.

(* Constructor declaration \texttt{C(\={C}~\={f})\{super(\={f}); this.\={f}=\={f};\}} and a constructor refinement 
 * \texttt{refines~C(\={E}~\={h}, \={C}~\={f}) \{original(\={f}); this.\={f}=\={f};\}} introduces a constructor with 
 * for the class \texttt{C} with fields \texttt{\=f} of type \texttt{\=C}. The constructor declaration body is simply 
 * a list of assignment of the arguments with its correspondent field preceded by calling its superclass constructor with the correspondent arguments.
 * The constructor refinement only differs from constructor declaration that instead of calling the superclass constructor
 * it will call its predecessor constructor (denoted by \texttt{original}).
 *)
Inductive Constructor :=
  | KDecl : id -> [FormalArg] -> [Argument] -> [Assignment] -> Constructor.


(* Method declaration \texttt{C~m~(\={C}~\={x})\ \{return~e;\}} 
 * introduces a method \texttt{m} of return type \texttt{C} with arguments \texttt{\={C}~\={x}} and body \texttt{e}.
 * Method declarations should only appear inside a class declaration.
 *)
Inductive MethodDecl :=
  | MDecl : ClassName -> id -> forall (fargs: [FormalArg]), NoDup (this :: refs fargs) -> Exp -> MethodDecl.


Instance MDeclRef : Referable MethodDecl :={
  ref mdecl := 
    match mdecl with 
   | MDecl _ id _ _ _ => id end
}.

(* A class declaration \texttt{class\ C~extends~D\ \{\={C} \={f}; K \={M}\}} 
 * introduces a class \texttt{C} with superclass \texttt{D}. This class has fields \texttt{\=f}
 * of type \texttt{C}, a constructor \texttt{K} and methdos \texttt{\=M}. The fields of class \texttt{C}
 * is \texttt{\=f} added to the fields of its superclass \texttt{D}, all of them must have distinct names.
 * Methods, in the other, hand may override another superclass method with the same name.
 * Method override in \ac{FJ} is basically method rewrite. 
 * Methods are uniquely identified by its name, i.e. overload is not supported.
 *)
Inductive ClassDecl:=
  | CDecl: id -> ClassName -> 
    forall (fDecls:[FieldDecl]), NoDup (refs fDecls) -> Constructor -> 
    forall (mDecls:[MethodDecl]), NoDup (refs mDecls) -> ClassDecl.

Instance CDeclRef : Referable ClassDecl :={
  ref cdecl := 
    match cdecl with 
   | CDecl id _ _ _ _ _ _ => id end
}.

Inductive Program :=
  | CProgram : forall (cDecls: [ClassDecl]), NoDup (refs cDecls) -> Exp -> Program.

(* We assume a fixed ClassTable *)
Parameter CT: [ClassDecl].

Require Import Relations Decidable.


Reserved Notation "C '<:' D " (at level 40).
(* Subtyping relation is (freely) generated by
    ClassTables
  in the following section we need to specify the restriction 
    on the ClassTables *)
Inductive Subtype : id -> ClassName -> Prop :=
  | S_Refl: forall C: ClassName, C <: C
  | S_Trans: forall (C D E: ClassName), 
    C <: D -> 
    D <: E -> 
    C <: E
  | S_Decl: forall C D fs noDupfs K mds noDupMds,
    find C CT = Some (CDecl C D fs noDupfs K mds noDupMds ) ->
    C <: D
where "C '<:' D" := (Subtype C D).
Hint Constructors Subtype.

Tactic Notation "subtype_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "S_Refl" | Case_aux c "S_Trans" 
  | Case_aux c "S_Decl"].

Reserved Notation "'mtype(' m ',' D ')' '=' c '~>' c0" (at level 40, c at next level).

Inductive m_type (m: id) (C: ClassName) (Bs: [ClassName]) (B: ClassName) : Prop:=
  | mty_ok : forall D Fs K Ms noDupfs noDupMds fargs noDupfargs e,
              find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds)->
              find m Ms = Some (MDecl B m fargs noDupfargs e) ->
              map fargType fargs = Bs ->
              mtype(m, C) = Bs ~> B
  | mty_no_override: forall D Fs K Ms noDupfs noDupMds,
              find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds) ->
              find m Ms = None ->
              mtype(m, D) = Bs ~> B ->
              mtype(m, C) = Bs ~> B
  where "'mtype(' m ',' D ')' '=' cs '~>' c0"
        := (m_type m D cs c0).

Tactic Notation "mtype_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "mty_ok" | Case_aux c "mty_no_override"].

Inductive m_body (m: id) (C: ClassName) (xs: [id]) (e: Exp) : Prop:=
  | mbdy_ok : forall D Fs K Ms noDupfs noDupMds C0 fargs noDupfargs,
              find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds)->
              find m Ms = Some (MDecl C0 m fargs noDupfargs e) ->
              refs fargs = xs ->
              m_body m C xs e
  | mbdy_no_override: forall D Fs K Ms noDupfs noDupMds,
              find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds)->
              find m Ms = None ->
              m_body m D xs e ->
              m_body m C xs e.
Notation "'mbody(' m ',' D ')' '=' xs 'o' e" := (m_body m D xs e) (at level 40).

Inductive fields : id -> [FieldDecl] -> Prop :=
 | F_Obj : fields Object nil
 | F_Decl : forall C D fs  noDupfs K mds noDupMds fs', 
     find C CT = Some (CDecl C D fs noDupfs K mds noDupMds) ->
     fields D fs' ->
     NoDup (refs (fs' ++ fs)) ->
     fields C (fs'++fs).
Tactic Notation "fields_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "F_Obj" | Case_aux c "F_Decl"].

Hint Constructors m_type m_body fields.
Tactic Notation "mbdy_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "mbdy_ok" | Case_aux c "mbdy_no_override"].

Fixpoint subst (e: Exp) (ds: [Exp]) (xs: [Var]): Exp := 
  match e with
  | ExpVar var => match find_where var xs with
                  | Some i => match nth_error ds i with
                                   | None => e | Some di => di end
                  | None => e end
  | ExpFieldAccess exp i => ExpFieldAccess (subst exp ds xs) i
  | ExpMethodInvoc exp i exps => 
      ExpMethodInvoc (subst exp ds xs) i (map (fun x => subst x ds xs) exps)
  | ExpCast cname exp => ExpCast cname (subst exp ds xs)
  | ExpNew cname exps => ExpNew cname (map (fun x => subst x ds xs) exps)
  end.
Notation " [; ds '\' xs ;] e " := (subst e ds xs) (at level 30).


Inductive Warning (s: string) : Prop :=
  | w_str : Warning s.
Notation stupid_warning := (Warning "stupid warning").

(* We can make a stupid cast at anytime, but that rule must be flagged. *)
Axiom STUPID_STEP : stupid_warning.

Reserved Notation "Gamma '|--' x ':' C" (at level 60, x at next level).
Inductive ExpTyping (Gamma: env ClassName) : Exp -> ClassName -> Prop :=
  | T_Var : forall x C, get Gamma x = Some C -> 
                Gamma |-- ExpVar x : C
  | T_Field: forall e0 C0 fs i Fi Ci fi,
                Gamma |-- e0 : C0 ->
                fields C0 fs ->
                nth_error fs i = Some Fi ->
                Ci = fieldType Fi ->
                fi = ref Fi ->
                Gamma |-- ExpFieldAccess e0 fi : Ci
  | T_Invk : forall e0 C Cs C0 Ds m es,
                Gamma |-- e0 : C0 ->
                mtype(m, C0) = Ds ~> C ->
                Forall2 (ExpTyping Gamma) es Cs ->
                Forall2 Subtype Cs Ds ->
                Gamma |-- ExpMethodInvoc e0 m es : C
  | T_New : forall C Ds Cs fs es,
                fields C fs ->
                Ds = map fieldType fs ->
                Forall2 (ExpTyping Gamma) es Cs ->
                Forall2 Subtype Cs Ds ->
                Gamma |-- ExpNew C es : C
  | T_UCast : forall e0 D C,
                Gamma |-- e0 : D ->
                D <: C ->
                Gamma |-- ExpCast C e0 : C
  | T_DCast : forall e0 C D,
                Gamma |-- e0 : D ->
                C <: D ->
                C <> D ->
                Gamma |-- ExpCast C e0 : C
  | T_SCast : forall e0 D C,
                Gamma |-- e0 : D ->
                ~ D <: C ->
                ~ C <: D ->
                stupid_warning ->
                Gamma |-- ExpCast C e0 : C
  where " Gamma '|--' e ':' C " := (ExpTyping Gamma e C).

Tactic Notation "typing_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "T_Var" | Case_aux c "T_Field" 
  | Case_aux c "T_Invk" | Case_aux c "T_New"
  | Case_aux c "T_UCast" | Case_aux c "T_DCast" 
  | Case_aux c "T_SCast"].

Reserved Notation "e '~>!' e1" (at level 59).
Inductive Computation_step : Exp -> Exp -> Prop :=
  | R_Field : forall C Fs es fi ei i,
            fields C Fs ->
            nth_error Fs i = Some fi ->
            nth_error es i = Some ei-> 
            ExpFieldAccess (ExpNew C es) (ref fi) ~>! ei
  | R_Invk : forall C m xs ds es e0,
            mbody(m, C) = xs o e0 ->
            NoDup (this :: xs) ->
            List.length ds = List.length xs ->
            ExpMethodInvoc (ExpNew C es) m ds ~>! [; ExpNew C es :: ds \ this :: xs;] e0
  | R_Cast : forall C D es,
            C <: D ->
            ExpCast D (ExpNew C es) ~>! ExpNew C es
  where "e '~>!' e1" := (Computation_step e e1).
Tactic Notation "computation_step_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "R_Field" | Case_aux c "R_Invk" 
  | Case_aux c "R_Cast" ].

Reserved Notation "e '~>' e1" (at level 60).
Inductive Computation : Exp -> Exp -> Prop :=
  | R_Step : forall e e1, e ~>! e1 -> e ~> e1
  | RC_Field : forall e0 e0' f,
            e0 ~> e0' ->
            ExpFieldAccess e0 f ~> ExpFieldAccess e0' f
  | RC_Invk_Recv : forall e0 e0' m es,
            e0 ~> e0' ->
            ExpMethodInvoc e0 m es ~> ExpMethodInvoc e0' m es
  | RC_Invk_Arg : forall e0 ei' m es es' ei i,
            ei ~> ei' ->
            nth_error es i = Some ei ->
            nth_error es' i = Some ei' ->
            (forall j, j <> i -> nth_error es j = nth_error es' j) ->
            length es = length es' ->
            ExpMethodInvoc e0 m es ~> ExpMethodInvoc e0 m es'
  | RC_New_Arg : forall C ei' es es' ei i,
            ei ~> ei' ->
            nth_error es i = Some ei ->
            nth_error es' i = Some ei' ->
            (forall j, j <> i -> nth_error es j = nth_error es' j) ->
            length es = length es' ->
            ExpNew C es ~> ExpNew C es'
  | RC_Cast : forall C e0 e0',
            e0 ~> e0' ->
            ExpCast C e0 ~> ExpCast C e0'
  where "e '~>' e1" := (Computation e e1).

Tactic Notation "computation_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "R_Step" | Case_aux c "RC_Field"
  | Case_aux c "RC_Invk_Recv" | Case_aux c "RC_Invk_Arg" 
  | Case_aux c "RC_New_Arg" | Case_aux c "RC_Cast"].

Inductive Value : Exp -> Prop :=
  v_new: forall C es, Value (ExpNew C es).


Reserved Notation "e '~>*' e1" (at level 59).
Inductive ComputationStar : Exp -> Exp -> Prop := 
  | Comp_Refl : forall e,
    e ~>* e
  | Comp_Trans: forall e1 e2 e3,
    e1 ~>* e2 ->
    e2 ~>* e3 ->
    e1 ~>* e2
  where "e '~>*' e1" := (ComputationStar e e1).
Hint Constructors Computation ExpTyping Value ComputationStar.
Definition normal_form {X:Type} (R: relation X) (t: X) :=
  ~exists t', R t t'.


Definition override (m: id) (D: ClassName) (Cs: [ClassName]) (C0: ClassName) :=
    (forall Ds D0, mtype(m, D) = Ds ~> D0 -> (Ds = Cs /\ C0 = D0)).

Inductive MType_OK : ClassName -> MethodDecl -> Prop :=
  | T_Method : forall C D C0 E0 xs Cs e0 Fs noDupfs K Ms noDupMds fargs m noDupFargs,
            nil extds (this :: xs) : (C :: Cs) |-- e0 : E0 ->
            E0 <: C0 ->
            find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds) ->
            override m D Cs C0 ->
            map fargType fargs = Cs ->
            refs fargs = xs ->
            find m Ms = Some (MDecl C0 m fargs noDupFargs e0) ->
            MType_OK C (MDecl C0 m fargs noDupFargs e0).

Inductive CType_OK: ClassDecl -> Prop :=
  | T_Class : forall C D Fs noDupfs K Ms noDupMds Cfargs Dfargs fdecl,
            K = KDecl C (Cfargs ++ Dfargs) (map Arg (refs Cfargs)) (zipWith Assgnmt (map (ExpFieldAccess (ExpVar this)) (refs Fs)) (map ExpVar (refs Fs))) ->
            fields D fdecl ->
            NoDup (refs (fdecl ++ Fs)) ->
            Forall (MType_OK C) (Ms) ->
            find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds) ->
            CType_OK (CDecl C D Fs noDupfs K Ms noDupMds).

(* Hypothesis for ClassTable sanity *)
Module CTSanity.



(* WFCT is basically saying classdecls are acyclic *)
Inductive WFCT : [ClassDecl] -> Prop :=
  | wfct_nil : WFCT nil 
  | wfct_cons:
      forall C D Fs noDupfs K Ms noDupMds l,
        (D = Object \/ find D l <> None) -> (* D exists in the list *)
        WFCT l ->
        WFCT ((CDecl C D Fs noDupfs K Ms noDupMds)::l).

(* This following one is easy to verify *)
Hypothesis obj_notin_dom: find Object CT = None.
Hint Rewrite obj_notin_dom.

(* This one is actually also easy to verify
    the essence is to make sure CT is acyclic *)
Hypothesis wfct : WFCT CT.


(* The following two is induction on CT *)
Theorem superClass_in_dom: forall C D Fs noDupfs K Ms noDupMds,
  find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds) ->
  D <> Object ->
  exists D0 Fs0 noDupfs0 K0 Ms0 noDupMds0, find D CT = Some (CDecl D D0 Fs0 noDupfs0 K0 Ms0 noDupMds0).
Admitted.

Theorem ClassesOK: forall C D Fs noDupfs K Ms noDupMds, 
  find C CT = Some (CDecl C D Fs noDupfs K Ms noDupMds) ->
  CType_OK (CDecl C D Fs noDupfs K Ms noDupMds).
Admitted.
Hint Resolve ClassesOK.



Lemma subtype_obj_obj: forall C,
  Object <: C ->
  Object = C.
Proof.
  intros_all. remember Object as Obj.
  induction H; crush.
Qed.

Lemma sub_not_obj: forall C,
  Object <> C ->
  ~ Object <: C.
Proof.
  Hint Resolve subtype_obj_obj.
  intros_all. remember Object as Obj.
  induction H; crush.
Qed.



Module subtype_dec.
(* A more proof-relevant subtype *)
Inductive nSubtype (CT : _) : [ClassName] -> ClassName -> ClassName -> Prop :=
  | nS_Refl: forall C: ClassName, nSubtype CT (C :: nil) C C
  | nS_Decl: forall C D E fs noDupfs K mds noDupMds trace,
    find C CT = Some (CDecl C D fs noDupfs K mds noDupMds ) ->
    nSubtype CT trace D E ->
    nSubtype CT (C::trace) C E.




Hint Constructors nSubtype.

Lemma nSubtype__Subtype:
  forall A B trace,
    nSubtype CT trace A B -> Subtype A B.
intros A B trace h.
induction h; intros; subst; eauto.
Qed.

Lemma nSubtype_trans:
  forall {A B t1},
  nSubtype CT t1 A B ->
    forall {C t2},
    nSubtype CT t2 B C ->
    exists t, nSubtype CT t A C.
  intros A B t1 h.
  induction h; intros; subst; eauto.
  destruct (IHh _ _ H0).  eauto.
Qed. 

Lemma Subtype__nSubtype:
  forall A B,
  A <: B -> (exists trace, nSubtype CT trace A B).
intros A B h. induction h; intros; subst; eauto.
destruct IHh1 as [t1 hh1].
destruct IHh2 as [t2 hh2].
forwards*: (nSubtype_trans hh1 hh2).
Qed.

(* This following one is a bit hard ... induction on what? 
    since now we have Subtype equivalence to nSubType
      we can induction on nSubtype now *)
Theorem antisym_subtype:
    antisymmetric _ Subtype.
Admitted.

(* All of the CT apperances in nSubType in the following
    might be generalized *)

Theorem nSubtype_unique':
  forall A B t1, 
    nSubtype CT t1 A B ->
    forall C t2,
    nSubtype CT t2 A C ->
    t1 = t2.
Admitted.


Theorem nSubtype_unique:
  forall A B t1 t2, 
    nSubtype CT t1 A B ->
    nSubtype CT t2 A B ->
    t1 = t2.
  intros; eauto using nSubtype_unique'.
Qed.
 



Lemma nSubtype_trace:
  forall A,
    find A CT <> None -> 
    exists t, nSubtype CT t A Object.
Admitted.

Lemma nSubtype_trace1:
  forall A B t,
    A <: B -> nSubtype CT t A Object -> In B t.
(* Use uniqueness, since B <: Object *)
Admitted.

Lemma nSubtype_trace2:
  forall A B t,
    nSubtype CT t A Object -> In B t -> exists t', nSubtype CT t' A B.
Admitted.

Lemma dec_subtype': forall C,
  find C CT <> None ->
  forall D,
  decidable (Subtype C D).
unfold decidable.
intros C h. destruct (nSubtype_trace C h) as [tr hh].
intros D.
(* Now we check if D is in tr *)
edestruct (in_dec beq_id_dec D tr).
destruct (nSubtype_trace2 C D tr); eauto. left. eapply nSubtype__Subtype; eauto.
right; intros H. forwards*: (nSubtype_trace1 C D tr).
Qed.

Lemma nonexistent_nonsubtype1:
  forall C D CT tr,
    find C CT = None ->
    C <> Object ->
    C <> D ->
    ~ nSubtype CT tr C D.
  intros C D CT tr h1 h2 h3 h4.
  generalize dependent h1.
  generalize dependent h2.
  generalize dependent h3.
  induction h4; intros; subst; eauto.
  rewrite H in *; try discriminate.
Qed.


(* Lemma superClass_in_dom2: forall C D,
  C <: D ->
  D <> Object ->
  exists D0 Fs0 noDupfs0 K0 Ms0 noDupMds0, find D CT = Some (CDecl D D0 Fs0 noDupfs0 K0 Ms0 noDupMds0).
Admitted. *)

Lemma nonexistent_nonsubtype2:
  forall C D CT tr,
    find D CT = None ->
    D <> Object ->
    C <> D ->
    ~ nSubtype CT tr C D.
  intros C D CT tr h1 h2 h3 h4.
  generalize dependent h1.
  generalize dependent h2.
  generalize dependent h3.
  induction h4; intros; subst; eauto.
(* This is provable using superClass_in_dom and WFCT *)
(* if D = Object, then E = Object
   if D <> Object, then find D CT = Some ...
    then by WFCT, E = Object or find E CT <> None
      Contradiction *)
Abort.

End subtype_dec.

(* The heart problem is to prove this *)
Lemma dec_subtype: forall C D,
  decidable (Subtype C D).
Proof.
  intros. unfold decidable.
  destruct beq_id_dec with C D. subst; eauto.
  destruct beq_id_dec with C Object. subst. right; apply sub_not_obj;auto.
  destruct find_dec with CT C. destruct e. gen H. gen C. gen D.
  induction CT; intros. inversion H. destruct beq_id_dec with C (ref a); subst; auto.
Admitted.

End CTSanity.

(*  *)